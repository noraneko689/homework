#include <iostream>
#include <vector>

using namespace std;

class StorageInfo {
protected:
    size_t nonZeroCount;

public:
    StorageInfo() : nonZeroCount(0) {}

    size_t getNonZeroCount() const {
        return nonZeroCount;
    }

    void updateNonZeroCount(size_t count) {
        nonZeroCount = count;
    }

    void printStorageInfo() const {
        cout << "Non-zero elements: " << nonZeroCount << endl;
    }
};

class Matrix {
private:
    int** data;
    size_t rows;
    size_t cols;

public:
    Matrix() : data(nullptr), rows(0), cols(0) {}

    Matrix(size_t r, size_t c) : rows(r), cols(c) {
        data = new int* [rows];
        for (size_t i = 0; i < rows; i++) {
            data[i] = new int[cols]();
        }
    }

    Matrix(const Matrix& other) : rows(other.rows), cols(other.cols) {
        data = new int* [rows];
        for (size_t i = 0; i < rows; i++) {
            data[i] = new int[cols];
            for (size_t j = 0; j < cols; j++) {
                data[i][j] = other.data[i][j];
            }
        }
    }

    virtual ~Matrix() {
        if (data) {
            for (size_t i = 0; i < rows; i++) {
                delete[] data[i];
            }
            delete[] data;
        }
    }

    size_t getRows() const { return this->rows; }
    size_t getCols() const { return this->cols; }

    int getElement(size_t row, size_t col) const {
        if (row < this->rows && col < this->cols) {
            return this->data[row][col];
        }
        return 0;
    }

    void setElement(size_t row, size_t col, int value) {
        if (row < this->rows && col < this->cols) {
            this->data[row][col] = value;
        }
    }

    Matrix& operator=(const Matrix& other) {
        if (this != &other) {
            if (this->data) {
                for (size_t i = 0; i < this->rows; i++) {
                    delete[] this->data[i];
                }
                delete[] this->data;
            }

            this->rows = other.rows;
            this->cols = other.cols;

            this->data = new int* [this->rows];
            for (size_t i = 0; i < this->rows; i++) {
                this->data[i] = new int[this->cols];
                for (size_t j = 0; j < this->cols; j++) {
                    this->data[i][j] = other.data[i][j];
                }
            }
        }
        return *this;
    }

    int* operator[](size_t row) {
        if (row < this->rows) {
            return this->data[row];
        }
        throw out_of_range("Row index out of range");
    }

    const int* operator[](size_t row) const {
        if (row < this->rows) {
            return this->data[row];
        }
        throw out_of_range("Row index out of range");
    }

    operator bool() const {
        return this->rows > 0 && this->cols > 0;
    }

    void print() const {
        for (size_t i = 0; i < this->rows; i++) {
            for (size_t j = 0; j < this->cols; j++) {
                cout << this->data[i][j] << " ";
            }
            cout << endl;
        }
    }

    friend Matrix operator+(const Matrix& m1, const Matrix& m2);
    friend Matrix operator*(const Matrix& m, int scalar);
    friend Matrix operator*(int scalar, const Matrix& m);
};

Matrix operator+(const Matrix& m1, const Matrix& m2) {
    if (m1.rows != m2.rows || m1.cols != m2.cols) {
        throw invalid_argument("Matrix dimensions must match for addition");
    }

    Matrix result(m1.rows, m1.cols);
    for (size_t i = 0; i < m1.rows; i++) {
        for (size_t j = 0; j < m1.cols; j++) {
            result.data[i][j] = m1.data[i][j] + m2.data[i][j];
        }
    }
    return result;
}

Matrix operator*(const Matrix& m, int scalar) {
    Matrix result(m.rows, m.cols);
    for (size_t i = 0; i < m.rows; i++) {
        for (size_t j = 0; j < m.cols; j++) {
            result.data[i][j] = m.data[i][j] * scalar;
        }
    }
    return result;
}

Matrix operator*(int scalar, const Matrix& m) {
    return m * scalar;
}
class SparseMatrix : public Matrix, public StorageInfo {
public:
    SparseMatrix(size_t r, size_t c) : Matrix(r, c) {
        updateNonZeroCount();
    }

    void setElement(size_t row, size_t col, int value) {
        int oldValue = getElement(row, col);
        Matrix::setElement(row, col, value);

        if (oldValue == 0 && value != 0) {
            nonZeroCount++;
        }
        else if (oldValue != 0 && value == 0) {
            nonZeroCount--;
        }
    }

    void updateNonZeroCount() {
        size_t count = 0;
        for (size_t i = 0; i < getRows(); i++) {
            for (size_t j = 0; j < getCols(); j++) {
                if (getElement(i, j) != 0) {
                    count++;
                }
            }
        }
        StorageInfo::updateNonZeroCount(count);
    }

    void printSparseInfo() const {
        cout << "Sparse Matrix " << getRows() << "x" << getCols() << ": ";
        printStorageInfo();
    }
};

int main() {
    cout << "=== Matrix Operations and Multiple Inheritance ===" << endl << endl;

    cout << "1. Creating matrices:" << endl;
    Matrix m1(2, 3);
    m1[0][0] = 1; m1[0][1] = 2; m1[0][2] = 3;
    m1[1][0] = 4; m1[1][1] = 5; m1[1][2] = 6;

    Matrix m2(2, 3);
    m2[0][0] = 6; m2[0][1] = 5; m2[0][2] = 4;
    m2[1][0] = 3; m2[1][1] = 2; m2[1][2] = 1;

    cout << "Matrix 1:" << endl;
    m1.print();
    cout << "Matrix 2:" << endl;
    m2.print();

    cout << endl;

    cout << "2. Matrix addition:" << endl;
    Matrix m3 = m1 + m2;
    m3.print();

    cout << endl;

    cout << "3. Scalar multiplication:" << endl;
    Matrix m4 = m1 * 2;
    cout << "Matrix 1 * 2:" << endl;
    m4.print();

    Matrix m5 = 3 * m2;
    cout << "3 * Matrix 2:" << endl;
    m5.print();

    cout << endl;

    cout << "4. Boolean conversion:" << endl;
    cout << "Matrix 1 is not empty: " << boolalpha << static_cast<bool>(m1) << endl;
    Matrix empty;
    cout << "Empty matrix is not empty: " << boolalpha << static_cast<bool>(empty) << endl;

    cout << endl;

    cout << "5. SparseMatrix demonstration:" << endl;
    SparseMatrix sparse(3, 3);
    sparse.setElement(0, 0, 1);
    sparse.setElement(1, 1, 2);
    sparse.setElement(2, 2, 3);

    cout << "Sparse matrix content:" << endl;
    sparse.print();
    sparse.printSparseInfo();

    cout << endl;

    cout << "6. Indexing operator:" << endl;
    cout << "Element at [1][1]: " << sparse[1][1] << endl;

    cout << endl;

    cout << "7. Updating sparse matrix:" << endl;
    sparse.setElement(0, 1, 5);
    sparse.print();
    sparse.printSparseInfo();

    cout << endl;

    cout << "=== Program completed ===" << endl;

    return 0;
}
